Your task is to create a visualizer specifically for this song:
https://public-file-hosting-lovely.s3.eu-west-1.amazonaws.com/mp3_20251118-200257_439435/fkn_face.mp3

Timeline of major changes
0:00–0:29 – Stable, mid-level drive (RMS ≈12 k) with no dramatic jumps; this is the intro/build foundation, ideal for establishing the overall color palette and root motion.
0:29–1:00 – Energy falls to ~6–8 k with several short quiet pockets (29.5–35 s, 46–48 s, 58.5–60 s). Those pockets feel like pre-drop atmospheric breaks; use them to shift to minimal visuals or spotlight a single element before the take-off.
1:00 – Sharp jump (+8 k) as the first big drop/chorus hits (high-energy windows at 67 s, 69 s, 82 s). This entire 60–90 s zone sustains top-tier energy, so throw in fast motion, bright flashes, or layered effects here.
2:00–2:07 – Deep dip from ~14.5 k to <1 k around 120–123.5 s, immediately restarting with another high-energy surge at 127.5 s (~9.5 k → 14.7 k). Treat this as a dramatic breakdown/resurgence; a sudden quiet frame followed by an explosive reboot suits the music.
2:52–3:00 – Energy wobbles again (dip at 179 s to ~5 k, back up at 180 s to ~13.5 k). Another release point—good for a contrasting rhythmic or color reset before heading toward the finale.
4:30–4:40 – Peak energy returns (≈16 k at 278.5 s). This final surge is the last climax before the outro.
4:59–5:01 – Energy collapses twice (~300 s down to ~25), so the song winds down into near silence—ideal for letting visuals fade out or freeze.

You are building a single, self-contained, GPU-accelerated music visualizer.

GOAL
- Create an “wow effect” realtime visualizer that reacts tightly to music.
- Prioritize modern, polished visuals, smooth animation, and strong use of GPU acceleration.
- Result should run interactively on a typical modern laptop.

CORE FEATURES
- Load and play a music file or accept live audio input from the user.
- Analyze audio in realtime (frequency spectrum, beat/onset detection, overall loudness).
- Drive all visual effects from this audio data so it feels clearly synchronized to the music.

VISUAL STYLE
- Fullscreen experience with a dark background as the base.
- Modern look: clean shapes, neon/glow, particles, waves, grids, or abstract forms.
- Depth and parallax if possible (camera motion, layering, scaling).
- Avoid “retro 90s Winamp clone” look; aim for something that could be used on stage or in a DJ set.

VISUAL MODES
- Implement at least 3 distinct visual modes (e.g., particle field, waveform/tunnel, geometric shapes).
- Each mode should respond differently to:
  - Bass (low frequencies)
  - Mids and highs
  - Overall volume and detected beats
- Add smooth transitions when switching between modes (no hard cuts).

AUDIO REACTIVITY
- Strong, visible reaction to:
  - Kick / bass hits (e.g., camera shake, global pulses, scale explosions)
  - Snare / clap (secondary pulses or color accents)
  - High-frequency content (sparkles, fine details, or line work)
- Use both slow, continuous changes (e.g., color gradients tied to average energy)
  and fast transient reactions (e.g., particles emitting on beats).

INTERACTION & CONTROL
- Basic controls:
  - Play / pause music
  - Switch visual modes
  - Adjust sensitivity / intensity of reactions
  - Toggle fullscreen
- Optional: a simple UI overlay that hides itself automatically after a few seconds of inactivity.

PERFORMANCE
- Use GPU acceleration for all heavy rendering work.
- Maintain smooth animation at a high frame rate if possible.
- Avoid unnecessary allocations and expensive CPU-side work in the main loop.

IMPLEMENTATION CONSTRAINTS
- You choose the exact libraries, APIs, and architecture.
- Do NOT explain frameworks or versions in detail; just implement with sensible defaults.
- Keep the code organized and readable so it can be extended with more modes later.

DELIVERABLE
- A single, runnable application.
- Clear instructions at the top of the main file on how to start it and how to provide a music file.
- Default configuration that works out-of-the-box without extra setup.

Now, implement this visualizer step by step, focusing on audio analysis quality, visual polish, and smooth performance.



