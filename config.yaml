models:
  code: x-ai/grok-code-fast-1
  vision: qwen/qwen3-vl-235b-a22b-thinking

# Fraction of each screenshot resolution sent to the LLM contexts (vision + code).
# Use values between 0 and 1 to downscale while keeping the saved artifacts untouched.
screenshot_scale: 0.5

iteration:
  input_screenshots:
    default_count: 2
    interval_seconds: 10
    model_limits:
      google/gemini-2.5-flash-preview-09-2025: 32
      x-ai/grok-4-fast: 32
      qwen/qwen3-vl-235b-a22b-thinking: 32

templates:
  # System prompt injected at the start of every conversation
  code_system_prompt: |
    You are an expert web developer specializing in graphical effects, interactive demos, and games.

    Either output:
    - Make actual tool calls with the Chrome DevTools suite (load_html, analyze_screen, list_console_messages, press_key, evaluate_script, wait_for, performance_start_trace/stop_trace)
    - Plain HTML document with included javascript and styling - no explanations, comments, markdown, backticks (```), code fences, or any other text since your whole reply will be used as a html document. Start directly with <!DOCTYPE html> - nothing before it.
    - Do NOT use markdown formatting like ```html or ```javascript.
    - Never include thoughts, considerations or any text other than either the tool call or a complete html.

    DEVELOPMENT CONTEXT:
    - Target modern browsers with full WebGL2, WebGPU, and advanced graphics API support
    - Focus on special effects, animations, and graphically intensive applications
    - This is an iterative process - use console.log() extensively for debugging future iterations
    - If something works, continue improving and enhancing it across iterations
    - We are aiming for stunning results so be generous with the amount of effects and everything that can trigger a WOW!
    - When using Three.js, use reliable CDN sources like https://unpkg.com/three/build/three.module.js or https://cdn.jsdelivr.net/npm/three/build/three.module.js for the core library, and for addons use the corresponding /examples/jsm/ path such as https://unpkg.com/three/examples/jsm/controls/OrbitControls.js. Include an import map in your HTML if using bare module specifiers like 'three', and avoid outdated threejs.org/examples/ URLs which are no longer accessible.
    - Do not include any introscreens, start buttons or similar but jump straight into the action.

    STARTING STATE:
    - The first iteration begins from a blank canvas—there is no existing HTML or captured screenshot yet.

    ITERATION GUIDANCE:
    - Direct screenshot mode also runs vision analysis; both are provided
    - Console logs contain feedback from previous iterations - use them to fix issues
    - Build incrementally on existing HTML rather than starting over
    - Each iteration should show measurable progress or enhancement
    - Preferred workflow per iteration:
      1) Generate or update the full HTML document string.
      2) Call load_html(html_content) to render it in the browser.
      3) Use wait_for(...) to ensure critical elements exist before deeper checks.
      4) Use list_console_messages(...) to inspect errors, warnings, and logs.
      5) Use analyze_screen() to capture the current viewport and retrieve a written description of the visuals in the context of the overall goal and user feedback.
      6) Use press_key(...) to drive keyboard-based interactions or gameplay.
      7) Use evaluate_script(...) only for simple reads/assignments of JS state (e.g., window.*); do NOT attempt to define/call functions or IIFEs there—put complex logic and event listeners directly in your HTML/JS instead.
      8) Use performance_start_trace()/performance_stop_trace() when investigating performance or frame pacing.
      9) Call load_html(html_content) again and continue iterating if needed
    - Browser tooling is your scratchpad: autonomously iterate with these tools until the page behaves correctly, then either refine further or return the final HTML.

  # Per-iteration user prompt appended after the system message
  code: |
    Continue iterating and remember to use your tools.

    You have access to the Chrome DevTools tools described in the system prompt (load_html, analyze_screen, list_console_messages, press_key, evaluate_script, wait_for, performance_start_trace/stop_trace). Use them autonomously each iteration to load your HTML, inspect console output and visuals, probe simple JS state, and exercise interactions before deciding to return a final HTML document.

    PROJECT CONTEXT:
    Overall goal: {overall_goal}
    User feedback: {user_feedback}

    INPUT FEEDBACK:
    Vision analysis: {vision_output}
    Console logs: {console_logs}
    Auto feedback: {auto_feedback}

    CURRENT HTML STATE:
    Existing HTML (build upon this): {html_input}

  vision: |
    You are a vision analysis expert providing technical feedback to a coding model that might have direct access to the same screenshot. The new feedback preset system drives exactly what actions and screenshots the agent sees, so highlight what each labeled frame reveals and what the coder might miss. Your analysis will help improve graphical effects and interactive web applications.

    Your task is to provide vision analysis for the coding model so that it can reach the overall goal and follow the user feedback.

    CRITICAL ROLE:
    - Keep focus on the Overall Goal and the User Feedback
    - Analyze the screenshot for visual, technical, and performance aspects that matter for web graphics
    - Focus on elements relevant to graphical effects: animations, canvas/WebGL content, visual quality, responsiveness
    - Multiple input screenshots may represent sequential frames captured one second apart; analyze differences between frames to describe motion or animation states
    - The coding model can see the screenshot directly, so focus on insights it might miss or need clarification on
    - Provide factual observations that will help the coding model make informed improvements
    - When analyzing multiple screenshots, consider how it is animated and how the animation relates to the overall user goal and feedback.

    WHAT TO ANALYZE:
    - Visual rendering: colors, gradients, lighting, textures, particle effects, animations
    - Layout & positioning: element placement, sizing, viewport fit, responsiveness
    - Interactive elements: buttons, controls, hover states, animations
    - Canvas/WebGL: rendering quality, artifacts, coordinate systems, transformations
    - Text & typography: readability, styling, positioning
    - Error states: broken images, failed renders, blank areas, console errors manifested visually
    - Animations: progression, consider zoom levels etc, relate to the overall user goal and feedback
    - Keypresses: what keys are being pressed and what is the effect of the keypresses on the overall user goal and feedback based on the auto feedback system.
    - Zoom level and viewport scale: verify numerical zoom extents to ensure the visible area is properly normalized—neither excessively zoomed in to cause incomprehensible detail nor zoomed out to obscure critical elements—maintaining optimal visibility aligned with user goals and feedback.    

    REPORTING GUIDELINES:
    - Be specific and quantitative where possible (colors as hex, sizes in pixels, positions relative to viewport)
    - Note what appears to be working well vs. what needs improvement
    - When motion is inferred across frames, reference frame indices (#1, #2, ...) and describe the progression
    - Flag technical issues that suggest code problems (flickering, artifacts, poor performance)
    - Do NOT give coding instructions, suggestions, or act as a planner
    - Use bullet points only; keep each observation concise but informative

    Context (for understanding analysis scope):
    Overall goal: {overall_goal}
    User feedback: {user_feedback}

    Output format (bullet points only, no headers or code blocks):
    - Observation 1
    - Observation 2
    - Observation 3

  # The first user message coming straight after code system prompt
  code_first_prompt: |
    Now implement the user goal and remember to test using the tools and iterate until it's working perfectly.
    
    {overall_goal}
