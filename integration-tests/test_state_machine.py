# integration-tests/test_state_machine.py
from __future__ import annotations

import asyncio
from pathlib import Path
from typing import List, Sequence, Tuple
import os
import sys


os.environ.setdefault("OPENROUTER_DISABLE_RETRY", "1")


def get_project_root() -> Path:
    return Path(__file__).resolve().parents[1]


def ensure_cwd_project_root() -> Path:
    root = get_project_root()
    os.chdir(root)
    return root


def inject_src_into_syspath(project_root: Path) -> None:
    # Ensure project root is on sys.path so we can import the src package
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))


# Test-local stub services (do not rely on network)
def _prompt_to_text(prompt) -> str:
    try:
        if hasattr(prompt, 'messages'):
            messages = list(getattr(prompt, 'messages', []) or [])
        elif isinstance(prompt, list):
            messages = list(prompt)
        else:
            return str(prompt or "")
        if not messages:
            return ""
        first = messages[0] or {}
        content = first.get('content', '') if isinstance(first, dict) else ''
        if isinstance(content, list):
            texts = [
                str(part.get('text', ''))
                for part in content
                if isinstance(part, dict) and part.get('type') == 'text'
            ]
            return "\n".join([t for t in texts if t])
        return str(content or "")
    except Exception:
        return str(prompt or "")


class _TestStubAICodeService:
    async def generate_html(self, prompt, model: str, worker: str = "main") -> str:
        await asyncio.sleep(0.05)
        safe = _prompt_to_text(prompt).strip()[:200]
        html = (
            "<!DOCTYPE html>\n"
            "<html><head><meta charset=\"utf-8\"><title>Generated Page</title>\n"
            "<style>body{font-family:sans-serif;padding:24px} .box{padding:16px;border:1px solid #ccc;border-radius:8px}</style>\n"
            "</head><body>\n"
            f"<h1>Generated by {model}</h1><div class=\"box\"><pre>{safe}</pre></div>\n"
            "<script>console.log('Page loaded');</script>\n"
            "</body></html>"
        )
        return html, "", {}


class _TestStubVisionService:
    async def analyze_screenshot(
        self,
        prompt: str,
        screenshot_paths: Sequence[str],
        console_logs: List[str],
        model: str,
        worker: str = "main",
    ) -> str:
        await asyncio.sleep(0.01)
        names = [Path(p).name for p in screenshot_paths]
        lines = [
            "Vision stub",
            f"Screenshots: {', '.join(names) if names else '(none)'}",
            f"Console entries: {len(console_logs)}",
            f"Prompt bytes: {len((prompt or '').encode('utf-8'))}",
            f"Model: {model}",
        ]
        return "\n".join(lines)


async def build_controller():
    from src.services import PlaywrightBrowserService
    from src.controller import IterationController

    ai = _TestStubAICodeService()
    browser = PlaywrightBrowserService()
    vision = _TestStubVisionService()
    return IterationController(ai, browser, vision)


def default_settings(overall_goal: str = ""):
    from src.interfaces import IterationMode, TransitionSettings
    from src import config as app_config

    cfg = app_config.get_config()
    code_model = cfg.code_model
    vision_model = cfg.vision_model
    return TransitionSettings(
        code_model=code_model,
        vision_model=vision_model,
        overall_goal=overall_goal,
        user_steering="",
        code_template=(
            "Improve the following HTML while adhering to the goal.\n"
            "Goal: {overall_goal}\n"
            "Vision analysis: {vision_output}\n"
            "User steering: {user_steering}\n"
            "HTML:\n{html_input}\n"
        ),
        vision_template=(
            "Analyze the HTML and its rendering to provide guidance.\n"
            "Goal: {overall_goal}\n"
            "User steering: {user_steering}\n"
            "HTML:\n{html_input}\n"
        ),
        mode=IterationMode.VISION_SUMMARY,
    )


async def test_linear_chain() -> Tuple[bool, str]:
    from src.interfaces import IterationNode

    ctrl = await build_controller()
    root_id = await ctrl.apply_transition(None, default_settings("Goal A"))
    child1_id = await ctrl.apply_transition(root_id, default_settings("Goal A"))
    child2_id = await ctrl.apply_transition(child1_id, default_settings("Goal A"))

    # Validate chain length and parent-child links
    root_node = ctrl.get_node(root_id)
    child1_node = ctrl.get_node(child1_id)
    child2_node = ctrl.get_node(child2_id)
    if not (root_node and child1_node and child2_node):
        return False, "Missing nodes in chain"
    if child1_node.parent_id != root_id:
        return False, "child1 parent link incorrect"
    if child2_node.parent_id != child1_id:
        return False, "child2 parent link incorrect"
    return True, "linear chain ok"


async def test_rerun_mid_chain() -> Tuple[bool, str]:
    ctrl = await build_controller()
    root_id = await ctrl.apply_transition(None, default_settings("Goal B"))
    child1_id = await ctrl.apply_transition(root_id, default_settings("Goal B"))
    child2_id = await ctrl.apply_transition(child1_id, default_settings("Goal B"))

    # Re-run from child1 with a modified code_model
    s = default_settings("Goal B")
    s.code_model = "modified-model"
    new_child_id = await ctrl.apply_transition(child1_id, s)

    # The old child2 should be deleted
    if ctrl.get_node(child2_id) is not None:
        return False, "descendant was not deleted on re-run"

    # New child should exist and be linked to child1
    new_child = ctrl.get_node(new_child_id)
    if not new_child or new_child.parent_id != child1_id:
        return False, "new child link incorrect"

    # Settings propagation: code_model equals edited value
    if new_child.settings.code_model != "modified-model":
        return False, "settings change did not propagate"
    return True, "re-run mid-chain ok"


async def test_artifacts_presence() -> Tuple[bool, str]:
    from src.interfaces import IterationNode

    ctrl = await build_controller()
    root_id = await ctrl.apply_transition(None, default_settings("Artifacts"))
    c1_id = await ctrl.apply_transition(root_id, default_settings("Artifacts"))

    for nid in [root_id, c1_id]:
        node = ctrl.get_node(nid)
        if not node:
            return False, f"node {nid} missing"
        out = next(iter(node.outputs.values()))
        p = Path(out.artifacts.screenshot_filename)
        if not p.exists():
            return False, f"screenshot missing for node {nid}: {p}"
        # Root may skip vision analysis; require non-empty for child
        if nid != root_id and not out.artifacts.vision_output.strip():
            return False, f"vision_output empty for node {nid}"
        if not isinstance(out.artifacts.console_logs, list):
            return False, f"console_logs not a list for node {nid}"
    return True, "artifacts present"


async def test_prompt_placeholders() -> Tuple[bool, str]:
    # Recording AI service to capture the prompt sent by δ
    from src.controller import IterationController, _compute_html_diff
    from src.interfaces import AICodeService, TransitionSettings
    from src.prompt_builder import _build_template_context
    from src.services import PlaywrightBrowserService

    class RecordingAICodeService(AICodeService):
        def __init__(self) -> None:
            self.last_prompt: str = ""
        async def generate_html(self, prompt, model: str, worker: str = "main") -> str:
            text = _prompt_to_text(prompt)
            self.last_prompt = text
            safe = text.strip()[:200]
            html = (
                "<!DOCTYPE html>\n"
                "<html><head><meta charset=\"utf-8\"><title>Generated Page</title>\n"
                "<style>body{font-family:sans-serif;padding:24px} .box{padding:16px;border:1px solid #ccc;border-radius:8px}</style>\n"
                "</head><body>\n"
                f"<h1>Generated from prompt</h1><div class=\"box\"><pre>{safe}</pre></div>\n"
                "<script>console.log('Page loaded');</script>\n"
                "</body></html>"
            )
            return html, "", {}

    ai = RecordingAICodeService()
    browser = PlaywrightBrowserService()
    vision = _TestStubVisionService()
    ctrl = IterationController(ai, browser, vision)

    settings = default_settings("Ensure placeholders")

    # Create root (no initial html_input). Then apply one transition; δ should
    # render root.html_output, compute vision_output, and build a code prompt
    # that includes all placeholders.
    root_id = await ctrl.apply_transition(None, settings)
    child_id = await ctrl.apply_transition(root_id, settings)
    root = ctrl.get_node(root_id)
    child = ctrl.get_node(child_id)
    if not (root and child):
        return False, "nodes missing"

    root_out = root.outputs[settings.code_model]
    child_out = child.outputs[settings.code_model]
    expected_prompt = settings.code_template.format(**_build_template_context(
        html_input=root_out.html_output,
        settings=settings,
        interpretation_summary=child_out.artifacts.vision_output,
        console_logs=child_out.artifacts.console_logs,
        html_diff=_compute_html_diff(root.html_input, root_out.html_output),
    ))

    if ai.last_prompt != expected_prompt:
        return False, "code prompt did not include expected placeholder substitutions"

    return True, "prompt placeholders substituted in code template"


async def test_multi_model_outputs() -> Tuple[bool, str]:
    ctrl = await build_controller()
    settings = default_settings("Multi")
    settings.code_model = "modelA,modelB"
    root_id = await ctrl.apply_transition(None, settings)
    root = ctrl.get_node(root_id)
    if not root:
        return False, "root missing"
    if set(root.outputs.keys()) != {"modelA", "modelB"}:
        return False, "outputs missing for models"
    # Iterate from modelA
    next_settings = default_settings("Multi")
    next_settings.code_model = "modelA"
    child_id = await ctrl.apply_transition(root_id, next_settings)
    child = ctrl.get_node(child_id)
    if not child:
        return False, "child missing"
    if child.html_input != root.outputs["modelA"].html_output:
        return False, "iteration did not use modelA output as input"
    return True, "multi model outputs ok"


async def test_shared_input_capture() -> Tuple[bool, str]:
    from src.interfaces import BrowserService
    from src.controller import IterationController

    class _CountingBrowserService(BrowserService):
        def __init__(self) -> None:
            self.calls: list[str] = []

        async def render_and_capture(
            self,
            html_code: str,
            worker: str = "main",
            *,
            capture_count: int = 1,
            interval_seconds: float = 1.0,
        ) -> tuple[List[str], List[str]]:
            self.calls.append(worker)
            try:
                count = int(capture_count)
            except Exception:
                count = 1
            count = max(1, count)
            files = [f"{worker}_{idx}.png" for idx in range(count)]
            return (files, [f"log-{worker}"])

    ai = _TestStubAICodeService()
    browser = _CountingBrowserService()
    vision = _TestStubVisionService()
    ctrl = IterationController(ai, browser, vision)

    s1 = default_settings("One")
    s1.code_model = "modelA"
    root_id = await ctrl.apply_transition(None, s1)

    s2 = default_settings("Two")
    s2.code_model = "modelA,modelB"
    await ctrl.apply_transition(root_id, s2)

    expected = ["modelA", "input", "modelA", "modelB"]
    if browser.calls != expected:
        return False, f"render sequence {browser.calls} != {expected}"
    return True, "shared input capture ok"


async def main() -> int:
    project_root = ensure_cwd_project_root()
    inject_src_into_syspath(project_root)

    checks = [
        ("Linear Chain", test_linear_chain),
        ("Re-run Mid-Chain", test_rerun_mid_chain),
        ("Artifact Presence", test_artifacts_presence),
        ("Prompt Placeholders", test_prompt_placeholders),
        ("Multi Model Outputs", test_multi_model_outputs),
        ("Shared Input Capture", test_shared_input_capture),
    ]

    ok_all = True
    for name, fn in checks:
        try:
            ok, msg = await fn()
        except Exception as exc:
            ok, msg = False, f"error: {exc}"
        status = "OK" if ok else "FAIL"
        print(f"[ {status} ] {name}: {msg}")
        ok_all = ok_all and ok

    return 0 if ok_all else 1


if __name__ == "__main__":
    raise SystemExit(asyncio.run(main()))
